## C/C++ 编译过程详解

------------------
### 基本概念

#### 1. 编译单元
- 编译器是以.c和.cpp为单位进行编译的，头文件.h只是一个文件，只有一个头文件被某个.c/.cpp直接或者间接#include了，
- 那么这个头文件里面的内容在编译的时候会直接拷贝到.c/.cpp中，成为编译单元的一部分（这一步叫预处理）。

#### 2. 编译过程
- 这里只讨论编译器为gcc/g++的情况。
- 编译的过程分为
    - 2.1 预处理
        - 作用：将#include的头文件内容拷贝到.c/.cpp中；替换所有的宏为实际定义值；删除注释；处理编译宏；处理完毕后的生成的中间件为.i文件。
        - g++ -E main.cpp -o main.i
    - 2.2 编译
        - 将预处理后的.i文件编译处理成汇编语言.s文件
        - g++ -S main.i   -o main.s
    - 2.3 汇编
        - 将汇编语言.s文件处理成二进制文件.o文件，这也是每个编译单元编译成功后生成的最终文件，该文件的内容无法在一般的编辑器中打开，可以在linux上用readelf命令查看里面的重要信息。（当前目录里面已经有了重定向readelf命令后的.o内容readelf_main.o.txt）
        - g++ -c main.s   -o main.o
        - readelf -a main.o > readelf_main.o.txt
    - 2.4 链接
        - 链接是为了生成最终的可执行文件（windows下是.exe，linux下是.out文件）或者链接生成静态库、动态库（例如L3代码里面的各个组件的.so），原理就是将所有的.o文件链接到一起。

#### 3. 声明和定义

#### 4. 符号表
- 
    - 4.1 未解决符号表
    - 定义：提供了所有在该编译单元里引用但是定义并不在本编译单元里的符号及其出现的地址。
    根目录下main.cpp中include了common.h，该头文件中声明了函数int Show(),同时main.cpp中调用了该函数，那么
    Show函数会以未定义的身份出现到main.o的符号表中。这些未定义的符号，一直到“2.3 编译”的时候都不会有问题，但是
    在2.4链接时，由于main.o有未解决符号表，那么他会去其他的.o中查找对方的导出符号表，查找到底是谁定义了该符号
    （函数或者变量，这里是Show函数），如果找到了，同时其他所有.o的未解决符号也都找到了，链接应该就能成功（这里写
    应该，是因为我还没有研究过链接过程）。
- 
    - 4.2 导出符号表
    - 定义：提供了本编译单元具有定义，并且愿意提供给其他编译单元使用的符号及其地址。
    TODO:补充

------------------
### 使用方式

- 本库使用IDE:vscode OS:mac OSX。编译方式为g++，如果使用环境为windows，需要安装g++，同时配置环境变量。
- 根目录下的main.i是预处理后生成的中间件，main.s是汇编后生成的中间件，main.o是编译完成后生成的最终件。可以简要理解为:
>* xxx.cpp + xxx.h --预处理--> xxx.i
>* xxx.i           ---汇编---> xxx.s
>* xxx.s           ---编译---> xxx.o
>* xxx.o + yyy.o ... zzz.o --链接--> xxx.so 或者 xxx.out 后者 xxx.exe等等


## C/C++ 程序内存详解

------------------
### 基本概念

#### 1. 数据区
- 1.1 _动态内存_  在程序运行起来后，运行到当前代码的时候才分配内存（所以叫动态内存）。
    - 1.1.1 栈 从高地址往低地址分配
    - 1.1.2 堆 从低地址往高地址分配
- 1.1 _静态内存_  在程序编译时已经知道要分配的内存（静态的静就是这个意思），当程序加载起来（还没执行任何函数）就会分配内存。该区域内存由程序结束后自动释放。静态内存位置比动态内存地址低。
    - 1.1.1 未初始化的全局变量，静态变量。
    - 1.1.2 常量区，存字符串常量("123")，数值常量(const int a = 1;)。
    - 1.1.3 已初始化的全局变量，静态变量。

#### 2. 代码区
- 
    - 存编译后的二进制代码，如函数体，类定义等？ // TODO:类待确认
    - 代码区在内存位置比数据区低。

------------------
### 推荐链接
[1]: http://www.cnblogs.com/jiqingwu/p/elf_format_research_01.html
[2]: https://blog.csdn.net/cxsydjn/article/details/79487805
1. .o .so .out等文件格式都属于ELF（Executable and Linking Format）文件,[ELF介绍][1]。
2. [C/C++程序的5种内存存储区及示意][2]

------------------
### 问题总结

#### 1. 为什么不要无脑添加各种头文件到.c/.cpp中？
    因为只要你#include某个头文件，预处理过程中就会将头文件里面的所有内容拷贝到.i文件中, 后续实际又没有
    用到这个头文件的内容，那么拷贝操作就降低了编译效率。
    
#### 2. 为什么全局变量不能定义在.h中？
    因为从功能看头文件就是提供接口给别的模块使用，那就意味着xxx.h会多个的.c/.cpp调用，如果.h中定义了一
    个全局变量例如int g_switch，这时候就代表所有include了该头文件的.c/.cpp编译生成的.o中都会定义自己
    的int g_switch全局变量（并进入导出符号表），编译生成.o的过程不会有问题，但是当链接时，这几个.o互相
    一“看”对方的导出符号表，发现大家都有int g_switch，就会报重定义错误。这个问题其实理解了 “.c/.cpp才
    是编译单元”，“.h只在预处理中以被拷贝的状态参与到编译”，这两点，应该就能搞懂。

#### 3. 既然.c/.cpp才是编译单元，编译报错信息显示错误点在.h中是为什么？
    这个问题的关键点还是“.c/.cpp才是编译单元”，“.h只在预处理中以被拷贝的状态参与到编译”，这两点。报错在
    .h中，那当然是因为你在某个.cpp中include了这个.h才会发生。

#### 4. extern “C" 定义的函数作用？
    这个功能是为了适配C与C++一个重大区别使用的。C++支持函数重载，而C不支持。extern "C"关键字只用在.cpp
    文件中。在.c中定义的函数，编译后的真实名称（符号）还是他本身；在.cpp中定义的函数，编译后的真实名称会
    发生变化。例如：
```C
    int Func(int para1, double para2)
    {
        return 1;
    }
```
    如果这个函数定义在.c文件中，该.c汇编生成的.s文件里面可以找到他的 “Func” 符号，对应我们换BIN后在
    串口调用桩函数，就可以直接输入 “Func 1 2.0” 执行。
    如果这个函数定义在.cpp文件中，该.cpp汇编生成.s文件里面对应符号已经变了，为“_Z4Funcid”，其中忽略
    “_Z”，下一个“4”是这个函数Func有4个字符，“Func”后面的"id"，是函数的入参int + double的缩写。所以
    如果我们在.cpp代码里面写了一个要去串口执行的桩函数，那么输入“Func 1 2.0” 是没有用的，因为符号表
    里面没有Func，只有_Z4Funcid。这时候，如果我们在定义该函数的时候，使用了extern "C"关键字，那么这
    个函数会以C风格编译，最终生成的符号还是Func。


#### 5. extern "C" 声明函数的作用    
    结合问题4分析。

#### 6. 多继承类的内存结构
    结合code/multi_derive内代码进行分析。